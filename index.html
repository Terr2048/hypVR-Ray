<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  <title>Hyperbolic Raymarching</title>
  <!-- Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <!-- Style
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <style>
      body {
          background-color: #000;
          color: #fff;
          margin: 0px;
          padding: 0;
          overflow: hidden;
      }
  </style>
  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="images/favicon.png">
</head>

<body>
  <img id="vr-icon" src="images/vr-icon.png" height="50px"
    style="
      position: fixed;
      bottom: 30px;
      right: 50px;
      display: none;
  "/>
</body>


<!-- Shaders
–––––––––––––––––––––––––––––––––––––––––––––––––– -->

<script type="x-shader/x-vertex" id="vertexShader">
  void main()
  {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
  }
</script>

<script type="x-shader/x-fragment" id="fragmentShader">
  const int MAX_MARCHING_STEPS = 255;
  const float MIN_DIST = 0.0;
  const float MAX_DIST = 100.0;
  const float EPSILON = 0.0001;

  uniform vec2 screenResolution;
  uniform vec3 cameraOrigin;
  uniform float fov;

  vec4 projectToHyperboloid(vec4 v) {
    float scaleFactor = sqrt(v.w * v.w - v.x * v.x - v.y * v.y - v.z * v.z);

    vec4 result;
    result.x = v.x / scaleFactor;
    result.y = v.y / scaleFactor;
    result.z = v.z / scaleFactor;
    result.w = v.w / scaleFactor;
    return result;
  }

  //Quaternion Math functions
  //-------------------------------------------------------
    float innerProduct(vec4 q1, vec4 q2){
      return q1.x*q2.x+q1.y*q2.y+q1.z*q2.z+q1.z*q2.z+q1.w*q2.w;
    }
    float quatDistance(vec4 q1, vec4 q2){
      float iP = innerProduct(q1,q2);
      return acos(2.0*iP*iP - 1.0);
    }
  //-------------------------------------------------------

  //Hyperbolic Math functions
  //-------------------------------------------------------
  float cosh(float rads){
    float eX = exp(rads);
    return (0.5 * (eX + 1.0/eX));
  }

  float sinh(float rads){
    float eX = exp(rads);
    return (0.5 * (eX - 1.0/eX));
  }

  float lorentzDot(vec4 u, vec4 v){
  	return u.x*v.x + u.y*v.y + u.z*v.z - u.w*v.w;
  }

  float hypNorm(vec4 v){
  	return sqrt(abs(lorentzDot(v,v)));
  }

  vec4 vFromVPrime(vec4 u, vec4 vPrime){
    vec4 v = vPrime - lorentzDot(u,vPrime)*u;
    return (1.0/hypNorm(v)*v);
  }
  //-------------------------------------------------------

  //Helps with full screen shaders
  //From https://github.com/hughsk/glsl-square-frame
  vec2 squareFrame(vec2 screenSize) {
    vec2 position = 2.0 * (gl_FragCoord.xy / screenSize.xy) - 1.0;
    position.x *= screenSize.x / screenSize.y;
    return position;
  }

  vec2 squareFrame(vec2 screenSize, vec2 coord) {
    vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;
    position.x *= screenSize.x / screenSize.y;
    return position;
  }

  //Based on http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/
  vec4 getRay(float fov, vec2 resolution, vec2 fragCoord){
    vec2 xy = fragCoord - resolution / 2.0;
    float z = resolution.y/tan(radians(fov)/2.0);
    vec4 p = projectToHyperboloid(vec4(vec3(xy,-z),1.0));
    return normalize(p);
  }

  //Raymarch functions http://iquilezles.org/www/articles/distfunctions/distfunctions.htm
  //-------------------------------------------------------
  float unionSDF(float d1, float d2){
    return min(d1, d2);
  }

  float differenceSDF(float d1, float d2){
    return max(-d1, d2);
  }

  //Raymarch primitives http://iquilezles.org/www/articles/distfunctions/distfunctions.htm

  /*float sphereSDF(vec3 samplePoint){
    return length(samplePoint) - 1.0;
  }

  float boxSDF(vec3 samplePoint, vec3 size){
    vec3 distance = abs(samplePoint) - size;
    return min(max(distance.x, max(distance.y,distance.z)), 0.0) + length(max(distance,0.0));
  }

  //custom primitives

  float hollowCubeSDF(vec3 samplePoint, float outerSize, float innerSize){
    vec3 oS = vec3(outerSize, outerSize, outerSize);
    vec3 iS = vec3(innerSize, innerSize, innerSize);
    float oB = boxSDF(samplePoint, oS);
    float iBX = boxSDF(samplePoint, vec3(oS.x*2.0, iS.y, iS.z));
    float iBY = boxSDF(samplePoint, vec3(iS.x, oS.y*2.0, iS.z));
    float iBZ = boxSDF(samplePoint, vec3(iS.x, iS.y, oS.z*2.0));
    float iB = unionSDF(iBX, iBY);
    iB = unionSDF(iB, iBZ);
    return differenceSDF(iB, oB);
  }

  //This is essentially our raymarch scene-graph

  float sceneSDF(vec3 samplePoint){
    float final = hollowCubeSDF(samplePoint, 3.0, 2.75);
    return final;
  }*/

  float sphereHSDF(vec4 samplePoint){
    return hypNorm(samplePoint) - 1.0;
  }

  float sceneHSDF(vec4 samplePoint){
    float final = sphereHSDF(samplePoint);
    return final;
  }
  //-------------------------------------------------------

  /*float shortestDistanceToSurface(vec3 rO, vec3 rD, float start, float end){
    float depth = start;
    for(int i = 0; i< MAX_MARCHING_STEPS; i++){
      float dist = sceneSDF(rO+depth*rD);
      if(dist < EPSILON){
        return depth;
      }
      depth += dist;
      if(depth >= end){
        return end;
      }
    }
    return end;
  }*/

  float shortestDistanceToSurface(vec4 rO, vec4 rD, float start, float end){
    float depth = start; //depth is in radians
    for(int i = 0; i< MAX_MARCHING_STEPS; i++){
      vec4 samplePoint = rO*cosh(depth)+rD*sinh(depth);
      float dist = sceneHSDF(samplePoint);
      if(dist < EPSILON){
        return depth;
      }
      depth += dist;
      if(depth >= end){
        return end;
      }
    }
    return end;
  }

  void main(){
    vec2 screenPosition = squareFrame(screenResolution);
    vec4 rayOrigin = projectToHyperboloid(vec4(cameraOrigin.xyz,1.0));
    vec4 rayDirVPrime = getRay(fov, screenPosition.xy, gl_FragCoord.xy);
    vec4 rayDirV = vFromVPrime(rayOrigin, rayDirVPrime);

    float dist = shortestDistanceToSurface(rayOrigin, rayDirV, MIN_DIST, MAX_DIST);
    if(dist > MAX_DIST - EPSILON){
      //Didn't hit anything
      gl_FragColor = vec4(0.1,0.1,0.1,1.0);
      return;
    }
    gl_FragColor = vec4(0.35,0.1,0.35,1.0);
  }
</script>

<!-- Scripts
–––––––––––––––––––––––––––––––––––––––––––––––––– -->
<script src="js/lib/three.min.js"></script>
<script src="js/HyperSpace.js" id="mainCode"></script>
<!--script src="js/HypMath.js"></script-->
</html>
