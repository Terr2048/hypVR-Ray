<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  <title>Hyperbolic Raymarching</title>
  <!-- Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <!-- Style
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <style>
      body {
          background-color: #000;
          color: #fff;
          margin: 0px;
          padding: 0;
          overflow: hidden;
      }
  </style>
  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="images/favicon.png">
</head>

<body>
  <img id="vr-icon" src="images/vr-icon.png" height="50px"
    style="
      position: fixed;
      bottom: 30px;
      right: 50px;
      display: none;
  "/>
</body>


<!-- Shaders
–––––––––––––––––––––––––––––––––––––––––––––––––– -->

<script type="x-shader/x-vertex" id="vertexShader">
  void main()
  {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
  }
</script>

<script type="x-shader/x-fragment" id="fragmentShader">
  const int MAX_MARCHING_STEPS = 127;
  const float MIN_DIST = 0.0;
  const float MAX_DIST = 10.0;
  const float EPSILON = 0.0001;
  const vec4 ORIGIN = vec4(0,0,0,1);

//  const float TILE_SIZE = 0.5306375310;  // 5 around an edge
  const float TILE_SIZE = 0.6584789485; // 6 around an edge
//  const float TILE_SIZE = 0.7245373613; // 7 around an edge
//  const float TILE_SIZE = 0.7642854597; // 8 around an edge
//  const float TILE_SIZE = 0.7903490689; // 9 around an edge
//  const float TILE_SIZE = 0.8084608338; // 10 around an edge
//  const float TILE_SIZE = 0.8215961187; // 11 around an edge
//  const float TILE_SIZE = 0.8314429455; // 12 around an edge

//  const float halfCubeWidth = 0.4858682718; // 5 around an edge
  const float halfCubeWidth = 0.5773502692; // 6 around an edge
//  const float halfCubeWidth = 0.6197119841; // 7 around an edge
//  const float halfCubeWidth = 0.6435942529; // 8 around an edge
//  const float halfCubeWidth = 0.6586067372; // 9 around an edge
//  const float halfCubeWidth = 0.6687403050; // 10 around an edge
//  const float halfCubeWidth = 0.6759376756; // 11 around an edge
//  const float halfCubeWidth = 0.6812500386; // 12 around an edge


  uniform vec2 screenResolution;
  uniform vec3 cameraOffset;
  uniform vec4 cameraQuat;
  uniform float fov;


  float lorentzDot(vec4 u, vec4 v){
    return u.w*v.w - u.x*v.x - u.y*v.y - u.z*v.z;
  }

  vec4 projectToHyperboloid(vec4 v) {
    return v/sqrt(lorentzDot(v,v));
  }

  vec3 qtransform( vec4 q, vec3 v ){
    return v + 2.0*cross(cross(v, -q.xyz ) + q.w*v, -q.xyz);
  }

  vec4 qmult(vec4 q, vec4 r){
    float a = r.x*q.x - r.y*q.y - r.z*q.z - r.w*q.w;
    float b = r.x*q.y + r.y*q.x - r.z*q.w + r.w*q.z;
    float c = r.x*q.z + r.y*q.w + r.z*q.x - r.w*q.y;
    float d = r.x*q.w - r.y*q.z - r.z*q.y + r.w*q.x;
    return vec4(a,b,c,d);
  }

  vec4 qinverse(vec4 q){
    float d = q.x*q.x+q.y*q.y+q.z*q.z+q.w*q.w;
    return vec4(-q.x/d, -q.y/d, -q.z/d, q.w/d);
  }

  //-------------------------------------------------------
  //Hyperbolic Math functions
  //-------------------------------------------------------
  float cosh(float rads){
    float eX = exp(rads);
    return (0.5 * (eX + 1.0/eX));
  }

  float sinh(float rads){
    float eX = exp(rads);
    return (0.5 * (eX - 1.0/eX));
  }

  float acosh(float rads){ //must be more than 1
    return log(rads + sqrt(rads*rads-1.0));
  }

  float hypNorm(vec4 v){
  	return sqrt(abs(lorentzDot(v,v)));
  }

  vec4 vPrimeFromV(vec4 u, vec4 v){
    vec4 w = v - lorentzDot(u, v)*u;
    return (1.0/hypNorm(w)*w);
  }

  float hypDistance(vec4 u, vec4 v){
    float bUV = lorentzDot(u,v);
    return acosh(bUV);
  }

  mat4 translateByVector(vec3 v) { // trickery from Jeff Weeks' Curved Spaces app
    float dx = v.x;
    float dy = v.y;
    float dz = v.z;
    float len = sqrt(dx*dx + dy*dy + dz*dz);
    if (len == 0.0)
    {
      return mat4(1.0);
    }
    else
      {
        dx /= len;
        dy /= len;
        dz /= len;
        mat4 m = mat4(
          vec4(0, 0, 0, dx),
          vec4(0, 0, 0, dy),
          vec4(0, 0, 0, dz),
          vec4(dx,dy,dz, 0)
        );
        mat4 m2 = m*m;
        float c1 = sinh(len);
        float c2 = cosh(len) - 1.0;
        return mat4(1.0) + c1 * m + c2 * m2;
      }
  }
  //generators is tiles without ORIGIN*
  mat4 generators[6];
  mat4 invGenerators[6];
  void initGENS(){
    generators[0] = translateByVector(vec3(2.0*TILE_SIZE, 0.0, 0.0)); //right
    generators[1] = translateByVector(vec3(-2.0*TILE_SIZE,0.0, 0.0)); //left
    generators[2] = translateByVector(vec3(0.0, 2.0*TILE_SIZE, 0.0)); //up
    generators[3] = translateByVector(vec3(0.0,-2.0*TILE_SIZE, 0.0)); //down
    generators[4] = translateByVector(vec3(0.0, 0.0, 2.0*TILE_SIZE)); //forward
    generators[5] = translateByVector(vec3(0.0, 0.0,-2.0*TILE_SIZE)); //back
  }
  void initInvGENS(){
    invGenerators[1] = generators[0]; //right
    invGenerators[0] = generators[1]; //left
    invGenerators[3] = generators[2]; //up
    invGenerators[2] = generators[3]; //down
    invGenerators[5] = generators[4]; //forward
    invGenerators[4] = generators[5]; //back
  }
  vec4 tiles[6];
  void initTILES(){
    for(int i=0; i<6; i++){
      tiles[i] = ORIGIN*generators[i];
    }
  }
  //-------------------------------------------------------

  vec4 getRay(float fov, vec2 resolution, vec2 fragCoord){
    vec2 xy = 0.2*((fragCoord - 0.5*resolution)/resolution.x);
    float z = 0.1;
    vec3 pPre = qtransform(cameraQuat, vec3(xy,z));
    vec4 p = projectToHyperboloid(vec4(pPre, 1.0));
    return p;
  }

  //Raymarch functions http://iquilezles.org/www/articles/distfunctions/distfunctions.htm
  //-------------------------------------------------------
  float unionSDF(float d1, float d2){
    return min(d1, d2);
  }

  float differenceSDF(float d1, float d2){
    return max(-d1, d2);
  }

  //Raymarch primitives

  float sphereHSDF(vec4 samplePoint, vec3 eTranslate, float size){
    return hypDistance(ORIGIN*translateByVector(eTranslate), samplePoint) - size;
  }

  float horosphereHSDF(vec4 samplePoint, vec4 lightRay){
    return log(lorentzDot(samplePoint, lightRay));
  }

  float sceneHSDF(vec4 samplePoint){
    float sphereInv = 0.5-sphereHSDF(samplePoint, vec3(0.0,0.0,0.0), 0.0);
    float horosphere = horosphereHSDF(abs(samplePoint), 1.5*vec4(halfCubeWidth, halfCubeWidth, halfCubeWidth, 1.0));
    float final = differenceSDF(horosphere, sphereInv);
    return final;
  }
  //-------------------------------------------------------


  bool isOutsideCell(vec4 samplePoint, out mat4 fixMatrix, out vec3 tiling){
    vec4 kleinSamplePoint = samplePoint/samplePoint.w;
    if(kleinSamplePoint.x > halfCubeWidth){
      fixMatrix = invGenerators[0];
      tiling.x += 1.0;
      return true;
    }
    if(kleinSamplePoint.x < -halfCubeWidth){
      fixMatrix = invGenerators[1];
      tiling.x -= 1.0;
      return true;
    }
    if(kleinSamplePoint.y > halfCubeWidth){
      fixMatrix = invGenerators[2];
      tiling.y += 1.0;
      return true;
    }
    if(kleinSamplePoint.y < -halfCubeWidth){
      fixMatrix = invGenerators[3];
      tiling.y -= 1.0;
      return true;
    }
    if(kleinSamplePoint.z > halfCubeWidth){
      fixMatrix = invGenerators[4];
      tiling.z += 1.0;
      return true;
    }
    if(kleinSamplePoint.z < -halfCubeWidth){
      fixMatrix = invGenerators[5];
      tiling.z -= 1.0;
      return true;
    }
    return false;
  }

  float shortestDistanceToSurface(vec4 rO, vec4 rD, float start, float end, out vec3 tiling){
    float totalDepth = start;
    float localDepth = totalDepth;
    mat4 fixMatrix;
    for(int i = 0; i< MAX_MARCHING_STEPS; i++){
      vec4 samplePoint = rO*cosh(localDepth)+rD*sinh(localDepth);
      if(isOutsideCell(samplePoint, fixMatrix, tiling)){
        vec4 newDirection = rO*cosh(localDepth+0.1) + rD*sinh(localDepth+0.1);
        rO = samplePoint*fixMatrix;
        newDirection *= fixMatrix;
        rO = projectToHyperboloid(rO);
        newDirection = projectToHyperboloid(newDirection);
        rD = vPrimeFromV(rO,newDirection);
        localDepth = start;
      }
      else{
        float dist = sceneHSDF(samplePoint);
        if(dist < EPSILON){
          return totalDepth;
        }
        totalDepth += dist;
        localDepth += dist;
        if(totalDepth >= end){
          return end;
        }
      }
    }
    return end;
  }

 //COLORING FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++
 vec3 estimateNormal(vec4 p) {
   return normalize(vec3(
       sceneHSDF(p*translateByVector(vec3(EPSILON,0.0,0.0))) - sceneHSDF(p*translateByVector(vec3(-EPSILON,0.0,0.0))),
       sceneHSDF(p*translateByVector(vec3(0.0,EPSILON,0.0))) - sceneHSDF(p*translateByVector(vec3(0.0,-EPSILON,0.0))),
       sceneHSDF(p*translateByVector(vec3(0.0,0.0,EPSILON))) - sceneHSDF(p*translateByVector(vec3(0.0,0.0,-EPSILON)))
   ));
 }
 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  void main(){
    initGENS();
    initInvGENS();
    initTILES();
    vec3 tiling = vec3(0.0);
    vec3 initOffset = vec3(0.0,0.0,0.0);
    vec4 rayOrigin = vec4(0.0,0.0,0.0,1.0);
    rayOrigin *= translateByVector(cameraOffset + initOffset);
    /*if(isOutsideCell(rayOrigin)){
      rayOrigin = fixOutsideCentralCell(rayOrigin, tiling);
    }*/
    vec4 rayDirV = getRay(90.0, screenResolution, gl_FragCoord.xy);
    rayDirV *= translateByVector(cameraOffset + initOffset);
    vec4 rayDirVPrime = vPrimeFromV(rayOrigin, rayDirV);

    float dist = shortestDistanceToSurface(rayOrigin, rayDirVPrime, MIN_DIST, MAX_DIST, tiling);
    if(dist > MAX_DIST - EPSILON){
      //Didn't hit anything
      gl_FragColor = vec4(rayDirVPrime.x,rayDirVPrime.y,rayDirVPrime.z,1.0);
      //gl_FragColor = vec4(0.0,0.0,0.0,1.0);
      return;
    }

    float depthColor = 1.0-dist/5.0;
    vec4 p = rayOrigin*cosh(dist)+rayDirV*sinh(dist);

    for(int i = 0; i<3; i++){
      if(tiling[i] > 0.0)
        p *= tiling[i]*invGenerators[i*2];
      else if(tiling[i] < 0.0)
        p *= tiling[i]*invGenerators[i*2+1];
    }
    vec3 color = estimateNormal(p);

    gl_FragColor = vec4(depthColor,depthColor*0.65,0.1,1.0);
    //gl_FragColor = vec4(color.x,color.y,color.z,1.0);
  }
</script>

<!-- Scripts
–––––––––––––––––––––––––––––––––––––––––––––––––– -->
<script src="js/lib/three.min.js"></script>
<script src="js/HypMath.js"></script>
<script src="js/vr/PhoneVR.js"></script>
<script src="js/vr/VRControlsHyperbolic.js"></script>
<script src="js/vr/VREffect.js"></script>
<script src="js/HyperSpace.js" id="mainCode"></script>
</html>
