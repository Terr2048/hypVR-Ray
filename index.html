<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  <title>Hyperbolic Raymarching</title>
  <!-- Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <!-- Style
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <style>
      body {
          background-color: #000;
          color: #fff;
          margin: 0px;
          padding: 0;
          overflow: hidden;
      }
  </style>
  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="images/favicon.png">
</head>

<body>
  <img id="vr-icon" src="images/vr-icon.png" height="50px"
    style="
      position: fixed;
      bottom: 30px;
      right: 50px;
      display: none;
  "/>
</body>


<!-- Shaders
–––––––––––––––––––––––––––––––––––––––––––––––––– -->

<script type="x-shader/x-vertex" id="vertexShader">
  void main()
  {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
  }
</script>

<script type="x-shader/x-fragment" id="fragmentShader">
  const int MAX_MARCHING_STEPS = 255;
  const float MIN_DIST = 0.0;
  const float MAX_DIST = 25.0;
  const float EPSILON = 0.0001;

  uniform vec2 screenResolution;
  uniform vec3 cameraOrigin;
  uniform vec4 cameraQuat;
  uniform float fov;

  //From https://www.opengl.org/discussion_boards/showthread.php/160134-Quaternion-functions-for-GLSL

  vec3 qtransform( vec4 q, vec3 v ){
    return v + 2.0*cross(cross(v, -q.xyz ) + q.w*v, -q.xyz);
  }

  //From http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/
  vec3 getRay(float fov, vec2 resolution, vec2 fragCoord){
    vec2 xy = fragCoord - resolution/2.0;
    float z = resolution.y/tan(radians(fov)/2.0);
    return normalize(vec3(xy,-z));
  }

  //Raymarch functions http://iquilezles.org/www/articles/distfunctions/distfunctions.htm

  float unionSDF(float d1, float d2){
    return min(d1, d2);
  }

  float differenceSDF(float d1, float d2){
    return max(-d1, d2);
  }

  //Raymarch primitives http://iquilezles.org/www/articles/distfunctions/distfunctions.htm

  float sphereSDF(vec3 samplePoint, float size){
    return length(samplePoint) - size;
  }

  float boxSDF(vec3 samplePoint, vec3 size){
    vec3 distance = abs(samplePoint) - size;
    return min(max(distance.x, max(distance.y,distance.z)), 0.0) + length(max(distance,0.0));
  }

  //custom primitives

  float hollowCubeSDF(vec3 samplePoint, float outerSize, float innerSize){
    vec3 oS = vec3(outerSize, outerSize, outerSize);
    vec3 iS = vec3(innerSize, innerSize, innerSize);
    float oB = boxSDF(samplePoint, oS);
    float iBX = boxSDF(samplePoint, vec3(oS.x*2.0, iS.y, iS.z));
    float iBY = boxSDF(samplePoint, vec3(iS.x, oS.y*2.0, iS.z));
    float iBZ = boxSDF(samplePoint, vec3(iS.x, iS.y, oS.z*2.0));
    float iB = unionSDF(iBX, iBY);
    iB = unionSDF(iB, iBZ);
    return differenceSDF(iB, oB);
  }

  //This is essentially our raymarch scene-graph
  //From http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/

  float sceneSDF(vec3 samplePoint){
    float final = hollowCubeSDF(samplePoint, 3.0, 2.75);
    final = unionSDF(final, sphereSDF(samplePoint, 1.0));
    return final;
  }

  float shortestDistanceToSurface(vec3 rO, vec3 rD, float start, float end){
    float depth = start;
    for(int i = 0; i< MAX_MARCHING_STEPS; i++){
      float dist = sceneSDF(rO+depth*rD);
      if(dist < EPSILON){
        return depth;
      }
      depth += dist;
      if(depth >= end){
        return end;
      }
    }
    return end;
  }

  //COLORING FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++

  vec3 estimateNormal(vec3 p) {
    return normalize(vec3(
        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),
        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),
        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))
    ));
  }
  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  void main(){
    vec3 rayOrigin = cameraOrigin;
    vec3 rayDirection = getRay(fov, screenResolution, gl_FragCoord.xy);
    vec3 worldDirection = qtransform(cameraQuat, rayDirection);
    float dist = shortestDistanceToSurface(rayOrigin, worldDirection, MIN_DIST, MAX_DIST);

    if(dist > MAX_DIST - EPSILON){
      //Didn't hit anything
      gl_FragColor = vec4(worldDirection.x, worldDirection.y, worldDirection.z, 1.0);
      return;
    }

    vec3 p = rayOrigin + dist * worldDirection;
    vec3 color = estimateNormal(p);
    gl_FragColor = vec4(p.x,p.y,p.z,1.0);
  }
</script>

<!-- Scripts
–––––––––––––––––––––––––––––––––––––––––––––––––– -->
<script src="js/lib/three.min.js"></script>
<script src="js/HypMath.js"></script>
<script src="js/vr/PhoneVR.js"></script>
<script src="js/vr/VRControlsHyperbolic.js"></script>
<script src="js/HyperSpace.js" id="mainCode"></script>
</html>
